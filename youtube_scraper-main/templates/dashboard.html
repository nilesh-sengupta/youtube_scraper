<!-- dashboard.html -->

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Dashboard</title>
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
            integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
            crossorigin="anonymous"
        />
        <script src="https://cdn.rawgit.com/dataarts/webgl-globe/2d24ba30/globe/third-party/three.min.js"></script>

        <link rel="stylesheet" href="../static/dashboard.css" />
    </head>
    <body>
        <div id="container" class="container">
            <br />
            <br />
            <br />
            <br />
            <br />

            <div class="landing">
                <div
                    class="left-landing"
                    style="display: flex; flex-direction: column; width: 50%"
                >
                    <div class="Htext">Welcome {{results}}</div>
                    <div class="Stext">
                        Personalized Sentiment Analyzer: A robust system for web scraping social media data related to government policies, new products, recent events, news articles, unstructured customer reviews present across the web etc. It uses natural language processing techniques to extract relevant information from the scraped data and applies machine learning algorithms to analyze the data and perceive the sentiment of the public. It aims to provide actionable insights to government organizations and businesses based on the evaluated reactions using data science as a pivot.
                    </div>

                    <button id="scroll">Explore</button>
                </div>

                <div id="globe"></div>
            </div>
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />

            <div class="title">Get Started</div>

            <div class="btn-group" role="group" aria-label="Monitoring Options">
                <div class="item">
                    <p class="btn-description">
                        Want to monitor interaction and performance of a
                        specific keyword or phase? <br />
                    </p>
                    <button
                        type="button"
                        class="btn btn-primary"
                        id="activeMonitoringBtn"
                    >
                        Active Monitoring
                    </button>
                </div>
                <div class="item">
                    <p class="btn-description">
                        Monitor a specific keyword/phrase! Great for one-time
                        use cases!
                    </p>
                    <!-- <button
                        type="button"
                        class="btn btn-success"
                        id="targetedMonitoringBtn"
                    >
                        Targeted Monitoring
                    </button> -->

                    <button
                        type="button"
                        class="btn btn-primary"
                        data-toggle="modal"
                        data-target="#exampleModal"
                    >
                        Targetted Monitoring
                    </button>
                </div>

                <div
                    class="modal fade"
                    id="exampleModal"
                    tabindex="-1"
                    role="dialog"
                    aria-labelledby="exampleModalLabel"
                    aria-hidden="true"
                >
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="exampleModalLabel">
                                    Targetted Monitoring
                                </h5>
                                <button
                                    type="button"
                                    class="close"
                                    data-dismiss="modal"
                                    aria-label="Close"
                                >
                                    <span aria-hidden="true">&times;</span>
                                </button>
                            </div>
                            <div class="modal-body">
                                <form id="search-form" action="/targettedmonitor" method="POST">

                                
                                <input id="search-term" class="modalInput" name="search_term" type="text" placeholder="search term" />
                                <input
                                    class="modalInput"
                                    type="text"
                                    name="num_vid"
                                    id="num-vid"
                                    placeholder="number of videos"
                                />
                                <div class="progress"  style="height: 20px">
                                    <div
                                        id="progress-bar"
                                        class="progress-bar progress-bar-striped"
                                        role="progressbar"
                                        style="width: 0%"
                                        aria-valuenow="25"
                                        aria-valuemin="0"
                                        aria-valuemax="100"
                                    ></div>
                                </div>
                                <div id="countdown" class="mt-2"></div>
                                <div id="estimated-time" class="mt-2"></div>
                            </div>
                            <div class="modal-footer">
                                
                                <button id="submitBtn" type="submit" class="btn btn-primary">
                                    Submit
                                </button>
                            </div>
                        </form>
                        </div>
                    </div>
                </div>
                <br />
                <br />
                <br />
                <br />
                <br />
                <br />
                <br />
                <br />
                <br />
                <br />
            </div>
        </div>

        <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
        <!-- <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-pzjw8HzfZIyCy5lAFqTRhu2oLDHKDdNpPd5c0pqtFqABdX94n3qE2IrtOb4q7A12"
            crossorigin="anonymous"
        ></script> -->

        <script
            src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            crossorigin="anonymous"
        ></script>
        <script
            src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"
        ></script>
        <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"
        ></script>

        <script>
            var DAT = DAT || {};

            document.getElementById('scroll').addEventListener('click', function() {
            console.log("clicked");
    
            var container = document.getElementById('container');
            var scrollDistance = container.offsetTop + 700; // Change 700 to the desired scroll distance

            window.scroll({
                top: scrollDistance,
                behavior: 'smooth'
            });
            });

            DAT.Globe = function (container, opts) {
                opts = opts || {};

                var colorFn =
                    opts.colorFn ||
                    function (x) {
                        var c = new THREE.Color();

                        c.setHSL(0.441 + x / 2, 0.6, 0.75);
                        return c;
                    };

                var Shaders = {
                    earth: {
                        uniforms: {
                            texture: { type: 't', value: null },
                        },
                        vertexShader: [
                            'varying vec3 vNormal;',
                            'varying vec2 vUv;',
                            'void main() {',
                            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.05 );',
                            'vNormal = normalize( normalMatrix * normal );',
                            'vUv = uv;',
                            '}',
                        ].join('\n'),
                        fragmentShader: [
                            'uniform sampler2D texture;',
                            'varying vec3 vNormal;',
                            'varying vec2 vUv;',
                            'void main() {',
                            'vec3 diffuse = texture2D( texture, vUv ).xyz;',
                            'float intensity = 1.05 - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) );',
                            'vec3 atmosphere = vec3( 0, 1.0, 1.0 ) * pow( intensity, 3.0 );',
                            'gl_FragColor = vec4( diffuse + atmosphere, 0.3 );',
                            '}',
                        ].join('\n'),
                    },
                    atmosphere: {
                        uniforms: {},
                        vertexShader: [
                            'varying vec3 vNormal;',
                            'void main() {',
                            'vNormal = normalize( normalMatrix * normal );',
                            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 0 );',
                            '}',
                        ].join('\n'),
                        fragmentShader: [
                            'varying vec3 vNormal;',
                            'void main() {',
                            'float intensity = pow( 0.8 - dot( vNormal, vec3( 0, 0, 1.0 ) ), 12.0 );',
                            'gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 ) * intensity;',
                            '}',
                        ].join('\n'),
                    },
                };

                var camera, scene, renderer, w, h;
                var mesh, atmosphere, point;

                var overRenderer;

                var curZoomSpeed = 0;
                var zoomSpeed = 50;

                var mouse = { x: 0, y: 0 },
                    mouseOnDown = { x: 0, y: 0 };
                var rotation = { x: 0, y: 0 },
                    target = { x: (Math.PI * 3) / 2, y: Math.PI / 6.0 },
                    targetOnDown = { x: 0, y: 0 };

                var distance = 1000000,
                    distanceTarget = 100000;
                var padding = 40;
                var PI_HALF = Math.PI / 2;

                function init() {
                    var shader, uniforms, material;
                    w = container.offsetWidth || window.innerWidth;
                    h = container.offsetHeight || window.innerHeight;

                    camera = new THREE.PerspectiveCamera(30, w / h, 1, 10000);
                    camera.position.z = distance;

                    scene = new THREE.Scene();

                    var geometry = new THREE.SphereGeometry(200, 40, 30);

                    shader = Shaders['earth'];
                    uniforms = THREE.UniformsUtils.clone(shader.uniforms);

                    THREE.ImageUtils.crossOrigin = '';

                    uniforms['texture'].value = THREE.ImageUtils.loadTexture(
                        'http://cdn.rawgit.com/dataarts/webgl-globe/2d24ba30/globe/world.jpg'
                    );

                    material = new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader,
                        transparent: true,
                    });

                    mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.y = Math.PI;
                    scene.add(mesh);

                    shader = Shaders['atmosphere'];
                    uniforms = THREE.UniformsUtils.clone(shader.uniforms);

                    material = new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                    });

                    mesh = new THREE.Mesh(geometry, material);
                    mesh.scale.set(1.1, 1.1, 1.1);
                    scene.add(mesh);

                    geometry = new THREE.BoxGeometry(0.75, 0.75, 1);
                    geometry.applyMatrix(
                        new THREE.Matrix4().makeTranslation(0, 0, -0.5)
                    );

                    point = new THREE.Mesh(geometry);

                    renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(w, h);

                    renderer.domElement.style.position = 'absolute';
                    renderer.setClearColor(0x161625);
                    // #161625

                    container.appendChild(renderer.domElement);

                    container.addEventListener('mousedown', onMouseDown, false);

                    container.addEventListener(
                        'mousewheel',
                        onMouseWheel,
                        false
                    );

                    document.addEventListener(
                        'keydown',
                        onDocumentKeyDown,
                        false
                    );

                    window.addEventListener('resize', onWindowResize, false);

                    container.addEventListener(
                        'mouseover',
                        function () {
                            overRenderer = true;
                        },
                        false
                    );

                    container.addEventListener(
                        'mouseout',
                        function () {
                            overRenderer = false;
                        },
                        false
                    );
                }

                function addData(data, opts) {
                    var lat, lng, size, color, i, step, colorFnWrapper;

                    step = 3;
                    colorFnWrapper = function (data, i) {
                        return colorFn(data[i + 2]);
                    };

                    var subgeo = new THREE.Geometry();

                    for (i = 0; i < data.length; i += step) {
                        lat = data[i];
                        lng = data[i + 1];
                        color = colorFnWrapper(data, i);
                        size = data[i + 2];
                        size = size * 200;
                        addPoint(lat, lng, size, color, subgeo);
                    }

                    this._baseGeometry = subgeo;
                }

                // material texture
                var mapFront = new THREE.Texture(generateTexture('front')),
                    mapBack = new THREE.Texture(generateTexture('back')),
                    mapLeft = new THREE.Texture(generateTexture('left')),
                    mapRight = new THREE.Texture(generateTexture('right')),
                    mapTop = new THREE.Texture(generateTexture('top'));

                mapFront.needsUpdate = true;
                mapBack.needsUpdate = true;
                mapLeft.needsUpdate = true;
                mapRight.needsUpdate = true;
                mapTop.needsUpdate = true;

                function createPoints() {
                    this.points = new THREE.Mesh(
                        this._baseGeometry,
                        new THREE.MeshFaceMaterial([
                            new THREE.MeshBasicMaterial({
                                map: mapLeft,
                                transparent: true,
                                vertexColors: THREE.FaceColors,
                            }),
                            new THREE.MeshBasicMaterial({
                                map: mapRight,
                                transparent: true,
                                vertexColors: THREE.FaceColors,
                            }),
                            new THREE.MeshBasicMaterial({
                                map: mapFront,
                                transparent: true,
                                vertexColors: THREE.FaceColors,
                            }),
                            new THREE.MeshBasicMaterial({
                                map: mapBack,
                                transparent: true,
                                vertexColors: THREE.FaceColors,
                            }),
                            // Bottom
                            new THREE.MeshBasicMaterial({
                                vertexColors: THREE.FaceColors,
                            }),
                            // Top
                            new THREE.MeshBasicMaterial({
                                transparent: true,
                                alphaTest: 1,
                            }),
                        ])
                    );

                    scene.add(this.points);
                }

                function addPoint(lat, lng, size, color, subgeo) {
                    var phi = ((90 - lat) * Math.PI) / 180;
                    var theta = ((180 - lng) * Math.PI) / 180;

                    point.position.x = 200 * Math.sin(phi) * Math.cos(theta);
                    point.position.y = 200 * Math.cos(phi);
                    point.position.z = 200 * Math.sin(phi) * Math.sin(theta);

                    point.lookAt(mesh.position);

                    point.scale.z = Math.max(size, 0.1); // avoid non-invertible matrix
                    point.updateMatrix();

                    for (var i = 0; i < point.geometry.faces.length; i++) {
                        point.geometry.faces[i].color = color;
                    }

                    if (point.matrixAutoUpdate) {
                        point.updateMatrix();
                    }

                    subgeo.merge(point.geometry, point.matrix);
                }

                function onMouseDown(event) {
                    event.preventDefault();

                    container.addEventListener('mousemove', onMouseMove, false);
                    container.addEventListener('mouseup', onMouseUp, false);
                    container.addEventListener('mouseout', onMouseOut, false);

                    mouseOnDown.x = -event.clientX;
                    mouseOnDown.y = event.clientY;

                    targetOnDown.x = target.x;
                    targetOnDown.y = target.y;

                    container.style.cursor = 'move';
                }

                function onMouseMove(event) {
                    mouse.x = -event.clientX;
                    mouse.y = event.clientY;

                    var zoomDamp = distance / 1000;

                    target.x =
                        targetOnDown.x +
                        (mouse.x - mouseOnDown.x) * 0.005 * zoomDamp;
                    target.y =
                        targetOnDown.y +
                        (mouse.y - mouseOnDown.y) * 0.005 * zoomDamp;

                    target.y = target.y > PI_HALF ? PI_HALF : target.y;
                    target.y = target.y < -PI_HALF ? -PI_HALF : target.y;
                }

                function onMouseUp(event) {
                    container.removeEventListener(
                        'mousemove',
                        onMouseMove,
                        false
                    );
                    container.removeEventListener('mouseup', onMouseUp, false);
                    container.removeEventListener(
                        'mouseout',
                        onMouseOut,
                        false
                    );
                    container.style.cursor = 'auto';
                }

                function onMouseOut(event) {
                    container.removeEventListener(
                        'mousemove',
                        onMouseMove,
                        false
                    );
                    container.removeEventListener('mouseup', onMouseUp, false);
                    container.removeEventListener(
                        'mouseout',
                        onMouseOut,
                        false
                    );
                }

                function onMouseWheel(event) {
                    event.preventDefault();
                    if (overRenderer) {
                        zoom(event.wheelDeltaY * 0.3);
                    }
                    return false;
                }

                function onDocumentKeyDown(event) {
                    switch (event.keyCode) {
                        case 38:
                            zoom(100);
                            event.preventDefault();
                            break;
                        case 40:
                            zoom(-100);
                            event.preventDefault();
                            break;
                    }
                }

                function onWindowResize(event) {
                    camera.aspect =
                        container.offsetWidth / container.offsetHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(
                        container.offsetWidth,
                        container.offsetHeight
                    );
                }

                function zoom(delta) {
                    distanceTarget -= delta;
                    distanceTarget =
                        distanceTarget > 1100 ? 1100 : distanceTarget;
                    distanceTarget =
                        distanceTarget < 350 ? 350 : distanceTarget;
                }

                function animate() {
                    requestAnimationFrame(animate);
                    render();
                }

                function render() {
                    zoom(curZoomSpeed);

                    rotation.x += 0.005;
                    rotation.y += (target.y - rotation.y) * 0.1;
                    distance += (distanceTarget - distance) * 0.8;

                    camera.position.x =
                        distance * Math.sin(rotation.x) * Math.cos(rotation.y);
                    camera.position.y = distance * Math.sin(rotation.y);
                    camera.position.z =
                        distance * Math.cos(rotation.x) * Math.cos(rotation.y);

                    camera.lookAt(mesh.position);

                    renderer.render(scene, camera);
                }

                init();
                this.animate = animate;

                this.__defineGetter__('time', function () {
                    return this._time || 0;
                });

                this.__defineSetter__('time', function (t) {
                    var validMorphs = [];
                    var morphDict = this.points.morphTargetDictionary;
                    for (var k in morphDict) {
                        if (k.indexOf('morphPadding') < 0) {
                            validMorphs.push(morphDict[k]);
                        }
                    }
                    validMorphs.sort();
                    var l = validMorphs.length - 1;
                    var scaledt = t * l + 1;
                    var index = Math.floor(scaledt);
                    for (i = 0; i < validMorphs.length; i++) {
                        this.points.morphTargetInfluences[validMorphs[i]] = 0;
                    }
                    var lastIndex = index - 1;
                    var leftover = scaledt - index;
                    if (lastIndex >= 0) {
                        this.points.morphTargetInfluences[lastIndex] =
                            1 - leftover;
                    }
                    this.points.morphTargetInfluences[index] = leftover;
                    this._time = t;
                });

                this.addData = addData;
                this.createPoints = createPoints;
                this.renderer = renderer;
                this.scene = scene;

                return this;
            };

            var container = document.getElementById('globe');
            var globe = new DAT.Globe(container);

            // console.log(container.innerWidth)

            var xhr = new XMLHttpRequest();

            xhr.open(
                'GET',
                'https://cdn.rawgit.com/dataarts/webgl-globe/2d24ba30/globe/population909500.json',
                true
            );

            xhr.onreadystatechange = function (e) {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        var data = JSON.parse(xhr.responseText);
                        window.data = data;
                        for (i = 0; i < data.length; i++) {
                            globe.addData(data[i][1], {
                                format: 'magnitude',
                                name: data[i][0],
                                animated: false,
                            });
                        }
                        globe.createPoints();
                        globe.animate();
                    }
                }
            };
            xhr.send(null);

            function generateTexture(alt) {
                var size = 16;

                // create canvas
                canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;

                // get context
                var context = canvas.getContext('2d');

                // draw gradient
                context.rect(0, 0, size, size);
                var gradient;

                if (alt == 'front' || alt == 'back') {
                    gradient = context.createLinearGradient(0, 0, 0, size);
                } else {
                    gradient = context.createLinearGradient(0, 0, size, 0);
                }

                if (alt == 'front') {
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(1, 'white');
                } else if (alt == 'back') {
                    gradient.addColorStop(1, 'transparent');
                    gradient.addColorStop(0, 'white');
                } else if (alt == 'left') {
                    gradient.addColorStop(1, 'transparent');
                    gradient.addColorStop(0, 'white');
                } else if (alt == 'right') {
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(1, 'white');
                } else {
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(1, 'white');
                }
                context.fillStyle = gradient;
                context.fill();

                return canvas;
            }
        </script>

        <!-- Your custom JavaScript goes here -->
        <script>
            // Wait for the document to be ready
            $(document).ready(function () {
                // Event listener for the Active Monitoring button
                $('#activeMonitoringBtn').on('click', function () {
                    // Make an AJAX request to the Active Monitoring route
                    $.ajax({
                        url: '/active-monitoring',
                        method: 'GET',
                        success: function (response) {
                            // Handle the response as needed
                            console.log(response);
                        },
                        error: function (xhr, status, error) {
                            console.error('Error:', error);
                        },
                    });
                });

                // Event listener for the Targeted Monitoring button
                // $('#targetedMonitoringBtn').on('click', function () {
                //     // Make an AJAX request to the Targeted Monitoring route
                //     $.ajax({
                //         url: 'http://127.0.0.1:5000/targettedmonitor',
                //         method: 'GET',
                //         success: function (response) {
                //             window.location.href = '/targettedmonitor';
                //             console.log(response);
                //         },
                //         error: function (xhr, status, error) {
                //             console.error('Error:', error);
                //         },
                //     });
                // });

                // $('#scroll').on('click', function () {
                //     console.log("clicked")
                //     $('html, body').animate(
                //         {
                //             scrollTop: $('#container').offset().top + 700, // Change 200 to the desired scroll distance
                //         },
                //         'slow'
                //     );
                // });
                // $('#submitBtn').on('click', function () {
                //     console.log("clicled")
                // });
            });




            // the form control

            $("#search-form").submit(function() {
        var search_term = $("#search-term").val();
        var num_vid = $("#num-vid").val();
        var progressBar = $("#progress-bar");
        var countdown = $("#countdown");
        var estimatedTime = $("#estimated-time");
        var totalTime = num_vid * 5;
        var remainingTime = totalTime;

        progressBar.css("width", "0%");
        // $(".progress").css("opacity", "1")

        estimatedTime.text("Estimated time remaining: " + totalTime + " seconds");
        var timer = setInterval(function() {
          remainingTime -= 1;
          var progress = 1 - remainingTime / totalTime;
          estimatedTime.text("Estimated time remaining: " + remainingTime + " seconds");
          progressBar.css("width", (progress * 100) + "%");
          if (remainingTime == 0) {
            clearInterval(timer);
          }
        }, 1000);
      });
    
        </script>
    </body>
</html>
